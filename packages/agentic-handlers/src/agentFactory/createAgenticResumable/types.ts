import type { InferVersionedArvoContract, OpenTelemetryHeaders } from 'arvo-core';
import type { Span } from '@opentelemetry/api';
import type { VersionedArvoContract } from 'arvo-core';
import type { z } from 'zod';
import type {
  AgenticMessageContentSchema,
  AgenticTextMessageContentSchema,
  AgenticToolCallMessageContentSchema,
  AgenticToolResultMessageContentSchema,
} from './schemas.js';
import type { toolUseApprovalContract } from './contracts/toolUseApproval.js';
import type { IMachineMemory } from 'arvo-event-handler';
import type { AgenticResumableContract } from './create.contract.js';
import type {} from 'arvo-core';

export type NonEmptyArray<T> = [T, ...T[]];

/**
 * Generic type alias for any versioned Arvo contract.
 * Used as a constraint for service contract type parameters.
 */
// biome-ignore lint/suspicious/noExplicitAny: Needs to be general
export type AnyVersionedContract = VersionedArvoContract<any, any>;

/**
 * Message content representing the result of a completed tool execution.
 *
 * Contains the output data from a tool that was previously invoked by the LLM.
 * The content is JSON-serialized and linked back to the original request via tool_use_id.
 */
export type AgenticToolResultMessageContent = z.infer<typeof AgenticToolResultMessageContentSchema>;

/**
 * Message content representing a request to execute a specific tool.
 *
 * Generated by LLMs when they determine that external tool execution is required
 * to fulfill a user request. Contains the tool name and all necessary parameters
 * for execution according to the tool's Arvo contract schema.
 */
export type AgenticToolCallMessageContent = z.infer<typeof AgenticToolCallMessageContentSchema>;

/**
 * Message content containing plain text communication.
 *
 * Represents standard conversational text without any tool interactions.
 * Used for both user messages and direct LLM responses that don't require tools.
 */
export type AgenticTextMessageContent = z.infer<typeof AgenticTextMessageContentSchema>;

/**
 * Union type for all possible message content formats in agentic conversations.
 * Supports text messages, tool execution requests, and tool result responses.
 */
export type AgenticMessageContent = z.infer<typeof AgenticMessageContentSchema>;

/**
 * Tool definition format expected by LLM services.
 *
 * Simplified representation of an Arvo service contract that provides
 * the LLM with the necessary information to understand and invoke tools.
 */
export type AgenticToolDefinition = {
  /** The name/identifier of the tool (maps to Arvo contract event type) */
  name: string;
  /** Human-readable description of what the tool does and when to use it */
  description: string;
  /** JSON schema defining the expected input parameters for the tool */
  input_schema: object;
};

/**
 * Input parameters for calling an agentic LLM service.
 *
 * Provides the LLM with conversation context, available tools, and configuration
 * needed to generate appropriate responses or tool execution requests. Supports
 * both conversation initialization and processing of tool execution results.
 */
export type LLMIntegrationParam = {
  /**
   * Indicates the conversation phase and expected LLM behavior.
   * - 'init': Starting a new conversation or processing a user message
   * - 'tool_results': Processing the results of previously requested tool executions
   */
  type: 'init' | 'tool_results';

  /**
   * Complete conversation history in chronological order.
   */
  messages: {
    role: 'user' | 'assistant';
    content: AgenticMessageContent[];
  }[];

  /**
   * Formatted tool definitions available to the LLM.
   *
   * These are derived from the service contracts and pre-formatted for
   * LLM consumption. Use the 'services' field to access original contracts
   * for type-safe tool parameter validation.
   */
  toolDefinitions: AgenticToolDefinition[];

  /** OpenTelemetry span for logging and tracing LLM operations */
  span: Span;

  /**
   * [Optional] Structured output format constraint.
   *
   * When provided, the LLM must return a JSON object matching this schema
   * instead of a plain text response. Useful for extracting structured data.
   */
  outputFormat: z.AnyZodObject | null;

  /** System prompt to guide the LLM's behavior and tool usage patterns */
  systemPrompt: string | null;
};

/**
 * Response from an agentic LLM service call.
 *
 * The LLM can either provide a direct response or request tool executions,
 * but not both simultaneously.
 */
export type LLMIntegrationOutput = {
  /**
   * Tool execution requests generated by the LLM.
   *
   * Each request is typed according to its Arvo contract, ensuring the
   * request data matches the expected service input schema. Null when
   * the LLM provides a direct response instead of requesting tools.
   */
  toolRequests: Array<{
    type: string;
    data: object;
    id: string;
  }> | null;

  /**
   * Direct response from the LLM.
   *
   * Can be a string for text responses or an object when outputFormat
   * is specified. Must be null when toolRequests are present.
   */
  response: string | object | null;

  /**
   * Aggregated count of tool requests by type.
   */
  toolTypeCount: Record<string, number>;

  /**
   * Optional token usage statistics from the LLM provider.
   * Helps with cost tracking and performance monitoring.
   */
  usage?: {
    tokens: {
      prompt: number;
      completion: number;
    };
  };
};

/**
 * Function signature every LLM integration must implement.
 *
 * Given conversation context, available tool definitions, and optional
 * structured-output constraints, the integration must return either:
 *
 * 1. A set of tool requests (`toolRequests`) when the LLM decides external
 *    actions are required, or
 * 2. A direct `response` (text or structured object) when no tools are needed.
 *
 * Implementations should ensure mutual exclusivity between `toolRequests`
 * and `response` (i.e., one is `null` while the other is populated).
 */
export type LLMIntergration = (param: LLMIntegrationParam) => Promise<LLMIntegrationOutput>;

/**
 * Interface for managing tool use approval decisions in persistent storage.
 *
 * Stores and retrieves approval decisions made by human reviewers, supporting
 * different approval durations (one-time use vs 24-hour access). This enables
 * the agent to remember and respect reviewer decisions without requesting
 * approval repeatedly for the same tool within the approved timeframe.
 */
export interface IToolUseApprovalMemory {
  /**
   * Stores an approval decision for a tools for a specific source.
   */
  setBatched(
    source: string,
    approvals: Record<
      string,
      Pick<
        InferVersionedArvoContract<
          VersionedArvoContract<typeof toolUseApprovalContract, '1.0.0'>
        >['emits']['evt.tool.approval.success']['data']['approvals'][number],
        'comments' | 'value'
      >
    >,
    otel: {
      parentSpan: Span;
      parentOtelHeaders: OpenTelemetryHeaders;
    },
  ): Promise<void>;

  /**
   * Retrieves the current approval status for a set of tools for a specific source.
   */
  getBatched(
    source: string,
    toolName: string[],
    otel: {
      parentSpan: Span;
      parentOtelHeaders: OpenTelemetryHeaders;
    },
  ): Promise<Record<string, { value: boolean; comment?: string }>>;
}

/**
 * Runtime state maintained throughout an agent's execution lifecycle.
 * Tracks conversation flow, tool usage patterns, and iteration limits.
 */
export type AgenticStateContext = {
  /** Current event subject being processed */
  currentSubject: string;
  /** Complete conversation history including system, user, and assistant messages */
  messages: LLMIntegrationParam['messages'];
  /** Counter tracking how many times each tool type has been invoked */
  toolTypeCount: Record<string, number>;
  /** Current iteration number in the tool calling loop */
  currentToolCallIteration: number;
  /** Maximum iterations allowed before forcing termination */
  maxToolCallIterationAllowed: number;
};

/**
 * Parameters passed to system prompt builders for generating contextual instructions.
 * Combines LLM configuration with agent metadata and approval workflows.
 */
export type AgenticSystemPromptBuilderParam = Pick<
  LLMIntegrationParam,
  'messages' | 'toolDefinitions' | 'type' | 'outputFormat'
> & {
  /** Human-readable name for the agent, used in user-facing interactions */
  alias: string | null;
  /** Unique system identifier for this handler */
  handlerSource: string;
  /** Brief explanation of the agent's capabilities and purpose */
  description: string | null;
  /** Maximum number of tool call iterations allowed, null for unlimited */
  maxToolInteractions: number | null;
  /** Configuration for tools requiring explicit approval before execution */
  toolApproval: {
    /** Names of tools that need approval (in their original format, not agent-formatted) */
    toolNames: NonEmptyArray<string>;
    /** Contract defining the approval request/response structure */
    contract: AnyVersionedContract;
  } | null;
  /** Configuration for requesting human input during execution */
  humanInteraction: {
    /** Contract defining the human interaction request/response structure */
    contract: AnyVersionedContract;
  } | null;
  /** Optional OpenTelemetry span for distributed tracing */
  span?: Span;
};

/**
 * Function signature for building dynamic system prompts based on agent context.
 * Implementations should generate appropriate instructions for the current execution phase.
 */
export type AgenticSystemPromptBuilderType = (param: AgenticSystemPromptBuilderParam) => string;

/**
 * Configuration parameters for creating an agentic resumable orchestrator.
 *
 * Defines all components needed to create an AI agent that can maintain
 * conversations, make intelligent tool decisions, and execute complex workflows
 * through Arvo's event-driven architecture. Supports both simple chat and
 * structured data extraction scenarios.
 */
export type CreateAgenticResumableParams<TContract extends AgenticResumableContract = AgenticResumableContract> = {
  /**
   *  The Resumable Contract that is bound to the resumable handler
   */
  contract: TContract;

  /**
   * LLM service integration function.
   *
   * Handles the actual communication with the LLM provider (OpenAI, Anthropic, etc.)
   * and implements the conversation and tool request logic.
   */
  llm: LLMIntergration;

  /**
   * The memory for the resumable to cache its state
   */
  memory: IMachineMemory<Record<string, unknown>>;

  /**
   * Available Arvo service contracts for tool execution.
   *
   * Each contract defines a service the LLM can invoke, providing full
   * type safety and automatic schema validation for tool parameters and responses.
   */
  services?: Record<
    string,
    | AnyVersionedContract
    | {
        contract: AnyVersionedContract;
        domains?: NonEmptyArray<string>;
        approval?:
          | boolean
          | {
              cache: boolean;
            };
      }
  >;

  /**
   * Dynamic system prompt generation function.
   *
   * Receives conversation context and available tools to generate contextually
   * appropriate system prompts for different conversation phases (init vs tool_results).
   */
  systemPrompt?: AgenticSystemPromptBuilderType;

  /**
   * Maximum number of times the LLM is allowed to perform tool calls.
   * Default is 5 times
   */
  maxToolInteractions?: number;

  /**
   * Configuration for requiring DIRECT human user approval before the agent can use specific tools.
   * Tools marked with [[REQUIRE APPROVAL]] in their description will trigger an approval
   * request before execution.
   */
  enableToolApproval?: {
    /**
     * A memory cache to store
     */
    memory?: IToolUseApprovalMemory;
    /**
     * Target domain(s) where approval request events should be routed.
     * Cannot be the default domain as approval requires human review flow.
     */
    domains: NonEmptyArray<string>;
  };

  /**
   * Configuration for interacting DIRECTLY with human user for reviews and clarification when the agent needs guidance or clarification.
   */
  enableHumanInteraction?: {
    /**
     * Target domain(s) where review request events should be routed.
     * Cannot be the default domain as reviews require human interaction.
     */
    domains: NonEmptyArray<string>;
  };
};
